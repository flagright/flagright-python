# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.acquisition_channel import AcquisitionChannel
from ..types.api_error_response import ApiErrorResponse
from ..types.boolean_string import BooleanString
from ..types.business_saved_payment_details_item import BusinessSavedPaymentDetailsItem
from ..types.business_with_rules_result import BusinessWithRulesResult
from ..types.device_data import DeviceData
from ..types.kyc_status_details import KycStatusDetails
from ..types.legal_entity import LegalEntity
from ..types.mcc_details import MccDetails
from ..types.payment_method import PaymentMethod
from ..types.person import Person
from ..types.person_attachment import PersonAttachment
from ..types.products_enabled import ProductsEnabled
from ..types.risk_level import RiskLevel
from ..types.transaction_limits import TransactionLimits
from ..types.user_entity_link import UserEntityLink
from ..types.user_state_details import UserStateDetails
from ..types.user_tag import UserTag
from .types.business_users_create_response import BusinessUsersCreateResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawBusinessUsersClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(
        self,
        *,
        user_id: str,
        created_timestamp: float,
        legal_entity: LegalEntity,
        lock_cra_risk_level: typing.Optional[BooleanString] = None,
        lock_kyc_risk_level: typing.Optional[BooleanString] = None,
        validate_user_id: typing.Optional[BooleanString] = None,
        activated_timestamp: typing.Optional[float] = OMIT,
        user_state_details: typing.Optional[UserStateDetails] = OMIT,
        kyc_status_details: typing.Optional[KycStatusDetails] = OMIT,
        share_holders: typing.Optional[typing.Sequence[Person]] = OMIT,
        directors: typing.Optional[typing.Sequence[Person]] = OMIT,
        transaction_limits: typing.Optional[TransactionLimits] = OMIT,
        risk_level: typing.Optional[RiskLevel] = OMIT,
        kyc_risk_level: typing.Optional[RiskLevel] = OMIT,
        allowed_payment_methods: typing.Optional[typing.Sequence[PaymentMethod]] = OMIT,
        last_transaction_timestamp: typing.Optional[float] = OMIT,
        linked_entities: typing.Optional[UserEntityLink] = OMIT,
        acquisition_channel: typing.Optional[AcquisitionChannel] = OMIT,
        saved_payment_details: typing.Optional[typing.Sequence[BusinessSavedPaymentDetailsItem]] = OMIT,
        mcc_details: typing.Optional[MccDetails] = OMIT,
        tags: typing.Optional[typing.Sequence[UserTag]] = OMIT,
        attachments: typing.Optional[typing.Sequence[PersonAttachment]] = OMIT,
        meta_data: typing.Optional[DeviceData] = OMIT,
        jurisdiction: typing.Optional[str] = OMIT,
        update_count: typing.Optional[float] = OMIT,
        products_enabled: typing.Optional[typing.Sequence[ProductsEnabled]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BusinessUsersCreateResponse]:
        """
        ## POST Business User

        `/business/user` endpoint allows you to operate on the Business user entity.

        In order to pass the payload of a User to Flagright and verify the User, you will need to call this endpoint with the User payload. Not all fields are mandatory, you will only need to pass in the fields that you have and are relevant for your compliance setup.

        ### Payload


        Each business user needs three mandatory fields:

        * `userId` - Unique identifier for the user
        * `legalEntity` - Details of the business legal entity (CompanyGeneralDetails, FinancialDetails etc) - only `legalName`in `CompanyGeneralDetails` is mandatory
        * `createdTimestamp` - UNIX timestamp in *milliseconds* for when the User is created in your system

        Parameters
        ----------
        user_id : str
            Unique user ID for the user

        created_timestamp : float
            Timestamp when the user was created

        legal_entity : LegalEntity

        lock_cra_risk_level : typing.Optional[BooleanString]
            Boolean string whether Flagright should lock the CRA risk level for the user.

        lock_kyc_risk_level : typing.Optional[BooleanString]
            Boolean string whether Flagright should lock the KYC risk level for the user.

        validate_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate the userId

        activated_timestamp : typing.Optional[float]
            Timestamp when the user was activated

        user_state_details : typing.Optional[UserStateDetails]

        kyc_status_details : typing.Optional[KycStatusDetails]

        share_holders : typing.Optional[typing.Sequence[Person]]
            Shareholders (beneficiaries) of the company that hold at least 25% ownership. Can be another company or an individual

        directors : typing.Optional[typing.Sequence[Person]]
            Director(s) of the company. Must be at least one

        transaction_limits : typing.Optional[TransactionLimits]

        risk_level : typing.Optional[RiskLevel]

        kyc_risk_level : typing.Optional[RiskLevel]

        allowed_payment_methods : typing.Optional[typing.Sequence[PaymentMethod]]

        last_transaction_timestamp : typing.Optional[float]
            Timestamp of the last successful transaction of the user

        linked_entities : typing.Optional[UserEntityLink]

        acquisition_channel : typing.Optional[AcquisitionChannel]

        saved_payment_details : typing.Optional[typing.Sequence[BusinessSavedPaymentDetailsItem]]

        mcc_details : typing.Optional[MccDetails]

        tags : typing.Optional[typing.Sequence[UserTag]]
            Additional information that can be added via tags

        attachments : typing.Optional[typing.Sequence[PersonAttachment]]
            User's attachments uploaded by business user

        meta_data : typing.Optional[DeviceData]

        jurisdiction : typing.Optional[str]
            Legal authority or region governing the transaction

        update_count : typing.Optional[float]

        products_enabled : typing.Optional[typing.Sequence[ProductsEnabled]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BusinessUsersCreateResponse]
            Created
        """
        _response = self._client_wrapper.httpx_client.request(
            "business/users",
            method="POST",
            params={
                "lockCraRiskLevel": lock_cra_risk_level,
                "lockKycRiskLevel": lock_kyc_risk_level,
                "validateUserId": validate_user_id,
            },
            json={
                "userId": user_id,
                "createdTimestamp": created_timestamp,
                "legalEntity": convert_and_respect_annotation_metadata(
                    object_=legal_entity, annotation=LegalEntity, direction="write"
                ),
                "activatedTimestamp": activated_timestamp,
                "userStateDetails": convert_and_respect_annotation_metadata(
                    object_=user_state_details, annotation=UserStateDetails, direction="write"
                ),
                "kycStatusDetails": convert_and_respect_annotation_metadata(
                    object_=kyc_status_details, annotation=KycStatusDetails, direction="write"
                ),
                "shareHolders": convert_and_respect_annotation_metadata(
                    object_=share_holders, annotation=typing.Sequence[Person], direction="write"
                ),
                "directors": convert_and_respect_annotation_metadata(
                    object_=directors, annotation=typing.Sequence[Person], direction="write"
                ),
                "transactionLimits": convert_and_respect_annotation_metadata(
                    object_=transaction_limits, annotation=TransactionLimits, direction="write"
                ),
                "riskLevel": risk_level,
                "kycRiskLevel": kyc_risk_level,
                "allowedPaymentMethods": allowed_payment_methods,
                "lastTransactionTimestamp": last_transaction_timestamp,
                "linkedEntities": convert_and_respect_annotation_metadata(
                    object_=linked_entities, annotation=UserEntityLink, direction="write"
                ),
                "acquisitionChannel": acquisition_channel,
                "savedPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=saved_payment_details,
                    annotation=typing.Sequence[BusinessSavedPaymentDetailsItem],
                    direction="write",
                ),
                "mccDetails": convert_and_respect_annotation_metadata(
                    object_=mcc_details, annotation=MccDetails, direction="write"
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags, annotation=typing.Sequence[UserTag], direction="write"
                ),
                "attachments": convert_and_respect_annotation_metadata(
                    object_=attachments, annotation=typing.Sequence[PersonAttachment], direction="write"
                ),
                "metaData": convert_and_respect_annotation_metadata(
                    object_=meta_data, annotation=DeviceData, direction="write"
                ),
                "jurisdiction": jurisdiction,
                "updateCount": update_count,
                "productsEnabled": convert_and_respect_annotation_metadata(
                    object_=products_enabled, annotation=typing.Sequence[ProductsEnabled], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BusinessUsersCreateResponse,
                    parse_obj_as(
                        type_=BusinessUsersCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self, user_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[BusinessWithRulesResult]:
        """
        ### GET Business User

        `/business/user` endpoint allows you to operate on the Business User entity.

        Calling `GET /business/user/{userId}` will return the entire User payload and rule execution results for the User with the corresponding `userId`

        Parameters
        ----------
        user_id : str


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BusinessWithRulesResult]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"business/users/{jsonable_encoder(user_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BusinessWithRulesResult,
                    parse_obj_as(
                        type_=BusinessWithRulesResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawBusinessUsersClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self,
        *,
        user_id: str,
        created_timestamp: float,
        legal_entity: LegalEntity,
        lock_cra_risk_level: typing.Optional[BooleanString] = None,
        lock_kyc_risk_level: typing.Optional[BooleanString] = None,
        validate_user_id: typing.Optional[BooleanString] = None,
        activated_timestamp: typing.Optional[float] = OMIT,
        user_state_details: typing.Optional[UserStateDetails] = OMIT,
        kyc_status_details: typing.Optional[KycStatusDetails] = OMIT,
        share_holders: typing.Optional[typing.Sequence[Person]] = OMIT,
        directors: typing.Optional[typing.Sequence[Person]] = OMIT,
        transaction_limits: typing.Optional[TransactionLimits] = OMIT,
        risk_level: typing.Optional[RiskLevel] = OMIT,
        kyc_risk_level: typing.Optional[RiskLevel] = OMIT,
        allowed_payment_methods: typing.Optional[typing.Sequence[PaymentMethod]] = OMIT,
        last_transaction_timestamp: typing.Optional[float] = OMIT,
        linked_entities: typing.Optional[UserEntityLink] = OMIT,
        acquisition_channel: typing.Optional[AcquisitionChannel] = OMIT,
        saved_payment_details: typing.Optional[typing.Sequence[BusinessSavedPaymentDetailsItem]] = OMIT,
        mcc_details: typing.Optional[MccDetails] = OMIT,
        tags: typing.Optional[typing.Sequence[UserTag]] = OMIT,
        attachments: typing.Optional[typing.Sequence[PersonAttachment]] = OMIT,
        meta_data: typing.Optional[DeviceData] = OMIT,
        jurisdiction: typing.Optional[str] = OMIT,
        update_count: typing.Optional[float] = OMIT,
        products_enabled: typing.Optional[typing.Sequence[ProductsEnabled]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BusinessUsersCreateResponse]:
        """
        ## POST Business User

        `/business/user` endpoint allows you to operate on the Business user entity.

        In order to pass the payload of a User to Flagright and verify the User, you will need to call this endpoint with the User payload. Not all fields are mandatory, you will only need to pass in the fields that you have and are relevant for your compliance setup.

        ### Payload


        Each business user needs three mandatory fields:

        * `userId` - Unique identifier for the user
        * `legalEntity` - Details of the business legal entity (CompanyGeneralDetails, FinancialDetails etc) - only `legalName`in `CompanyGeneralDetails` is mandatory
        * `createdTimestamp` - UNIX timestamp in *milliseconds* for when the User is created in your system

        Parameters
        ----------
        user_id : str
            Unique user ID for the user

        created_timestamp : float
            Timestamp when the user was created

        legal_entity : LegalEntity

        lock_cra_risk_level : typing.Optional[BooleanString]
            Boolean string whether Flagright should lock the CRA risk level for the user.

        lock_kyc_risk_level : typing.Optional[BooleanString]
            Boolean string whether Flagright should lock the KYC risk level for the user.

        validate_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate the userId

        activated_timestamp : typing.Optional[float]
            Timestamp when the user was activated

        user_state_details : typing.Optional[UserStateDetails]

        kyc_status_details : typing.Optional[KycStatusDetails]

        share_holders : typing.Optional[typing.Sequence[Person]]
            Shareholders (beneficiaries) of the company that hold at least 25% ownership. Can be another company or an individual

        directors : typing.Optional[typing.Sequence[Person]]
            Director(s) of the company. Must be at least one

        transaction_limits : typing.Optional[TransactionLimits]

        risk_level : typing.Optional[RiskLevel]

        kyc_risk_level : typing.Optional[RiskLevel]

        allowed_payment_methods : typing.Optional[typing.Sequence[PaymentMethod]]

        last_transaction_timestamp : typing.Optional[float]
            Timestamp of the last successful transaction of the user

        linked_entities : typing.Optional[UserEntityLink]

        acquisition_channel : typing.Optional[AcquisitionChannel]

        saved_payment_details : typing.Optional[typing.Sequence[BusinessSavedPaymentDetailsItem]]

        mcc_details : typing.Optional[MccDetails]

        tags : typing.Optional[typing.Sequence[UserTag]]
            Additional information that can be added via tags

        attachments : typing.Optional[typing.Sequence[PersonAttachment]]
            User's attachments uploaded by business user

        meta_data : typing.Optional[DeviceData]

        jurisdiction : typing.Optional[str]
            Legal authority or region governing the transaction

        update_count : typing.Optional[float]

        products_enabled : typing.Optional[typing.Sequence[ProductsEnabled]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BusinessUsersCreateResponse]
            Created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "business/users",
            method="POST",
            params={
                "lockCraRiskLevel": lock_cra_risk_level,
                "lockKycRiskLevel": lock_kyc_risk_level,
                "validateUserId": validate_user_id,
            },
            json={
                "userId": user_id,
                "createdTimestamp": created_timestamp,
                "legalEntity": convert_and_respect_annotation_metadata(
                    object_=legal_entity, annotation=LegalEntity, direction="write"
                ),
                "activatedTimestamp": activated_timestamp,
                "userStateDetails": convert_and_respect_annotation_metadata(
                    object_=user_state_details, annotation=UserStateDetails, direction="write"
                ),
                "kycStatusDetails": convert_and_respect_annotation_metadata(
                    object_=kyc_status_details, annotation=KycStatusDetails, direction="write"
                ),
                "shareHolders": convert_and_respect_annotation_metadata(
                    object_=share_holders, annotation=typing.Sequence[Person], direction="write"
                ),
                "directors": convert_and_respect_annotation_metadata(
                    object_=directors, annotation=typing.Sequence[Person], direction="write"
                ),
                "transactionLimits": convert_and_respect_annotation_metadata(
                    object_=transaction_limits, annotation=TransactionLimits, direction="write"
                ),
                "riskLevel": risk_level,
                "kycRiskLevel": kyc_risk_level,
                "allowedPaymentMethods": allowed_payment_methods,
                "lastTransactionTimestamp": last_transaction_timestamp,
                "linkedEntities": convert_and_respect_annotation_metadata(
                    object_=linked_entities, annotation=UserEntityLink, direction="write"
                ),
                "acquisitionChannel": acquisition_channel,
                "savedPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=saved_payment_details,
                    annotation=typing.Sequence[BusinessSavedPaymentDetailsItem],
                    direction="write",
                ),
                "mccDetails": convert_and_respect_annotation_metadata(
                    object_=mcc_details, annotation=MccDetails, direction="write"
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags, annotation=typing.Sequence[UserTag], direction="write"
                ),
                "attachments": convert_and_respect_annotation_metadata(
                    object_=attachments, annotation=typing.Sequence[PersonAttachment], direction="write"
                ),
                "metaData": convert_and_respect_annotation_metadata(
                    object_=meta_data, annotation=DeviceData, direction="write"
                ),
                "jurisdiction": jurisdiction,
                "updateCount": update_count,
                "productsEnabled": convert_and_respect_annotation_metadata(
                    object_=products_enabled, annotation=typing.Sequence[ProductsEnabled], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BusinessUsersCreateResponse,
                    parse_obj_as(
                        type_=BusinessUsersCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, user_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[BusinessWithRulesResult]:
        """
        ### GET Business User

        `/business/user` endpoint allows you to operate on the Business User entity.

        Calling `GET /business/user/{userId}` will return the entire User payload and rule execution results for the User with the corresponding `userId`

        Parameters
        ----------
        user_id : str


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BusinessWithRulesResult]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"business/users/{jsonable_encoder(user_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BusinessWithRulesResult,
                    parse_obj_as(
                        type_=BusinessWithRulesResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

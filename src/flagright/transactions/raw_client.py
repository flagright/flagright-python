# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.api_error_response import ApiErrorResponse
from ..types.boolean_string import BooleanString
from ..types.device_data import DeviceData
from ..types.origin_funds_info import OriginFundsInfo
from ..types.tag import Tag
from ..types.transaction_amount_details import TransactionAmountDetails
from ..types.transaction_destination_payment_details import TransactionDestinationPaymentDetails
from ..types.transaction_origin_payment_details import TransactionOriginPaymentDetails
from ..types.transaction_state import TransactionState
from ..types.transaction_with_rules_result import TransactionWithRulesResult
from .types.transactions_verify_response import TransactionsVerifyResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawTransactionsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def verify(
        self,
        *,
        type: str,
        transaction_id: str,
        timestamp: float,
        validate_origin_user_id: typing.Optional[BooleanString] = None,
        validate_destination_user_id: typing.Optional[BooleanString] = None,
        origin_user_id: typing.Optional[str] = OMIT,
        destination_user_id: typing.Optional[str] = OMIT,
        transaction_state: typing.Optional[TransactionState] = OMIT,
        origin_amount_details: typing.Optional[TransactionAmountDetails] = OMIT,
        destination_amount_details: typing.Optional[TransactionAmountDetails] = OMIT,
        origin_payment_details: typing.Optional[TransactionOriginPaymentDetails] = OMIT,
        destination_payment_details: typing.Optional[TransactionDestinationPaymentDetails] = OMIT,
        origin_funds_info: typing.Optional[OriginFundsInfo] = OMIT,
        related_transaction_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        product_type: typing.Optional[str] = OMIT,
        promotion_code_used: typing.Optional[bool] = OMIT,
        reference: typing.Optional[str] = OMIT,
        origin_device_data: typing.Optional[DeviceData] = OMIT,
        destination_device_data: typing.Optional[DeviceData] = OMIT,
        tags: typing.Optional[typing.Sequence[Tag]] = OMIT,
        jurisdiction: typing.Optional[str] = OMIT,
        update_count: typing.Optional[float] = OMIT,
        payment_approval_timestamp: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TransactionsVerifyResponse]:
        """
        ## POST Transactions

        `/transactions` endpoint allows you to operate on the [Transaction entity.](/guides/overview/entities#transaction)

        In order to pass the payload of a transaction to Flagright and verify the transaction, you will need to call this endpoint with the transaction payload. Not all fields are mandatory, you will only need to pass in the fields that you have and are relevant for your compliance setup.


        ### Payload

        Here are some of the most used payload fields explained (you can find the full payload [schema below](/api-reference/api-reference/transactions/verify#request) with 1 line descriptions):

        * `type`: Type of transaction (Ex: `WITHDRAWAL`, `DEPOSIT`, `TRANSFER` etc).
        * `transactionId` - Unique Identifier for the transaction.
        * `timestamp` - UNIX timestamp in *milliseconds* of when the transaction took place
        * `transactionState` - The state of the transaction, set to `CREATED` by default. [More details here](/guides/overview/entities#transaction-lifecycle-through-transaction-events)
        * `originUserId` - Unique identifier (if any) of the user who is sending the money. This user must be created within the Flagright system before using the [create a consumer user](/api-reference/api-reference/consumer-users/create) or [create a business user](/api-reference/api-reference/business-users/create) endpoint
        * `destinationUserId` - Unique identifier (if any) of the user who is receiving the money. This user must be created within the Flagright system before using the [create a consumer user](/api-reference/api-reference/consumer-users/create) or [create a business user](/api-reference/api-reference/business-users/create) endpoint
        * `originAmountDetails` - Details of the amount being sent from the origin
        * `destinationAmountDetails` - Details of the amount being received at the destination
        * `originPaymentDetails` - Payment details (if any) used at the origin (ex: `CARD`, `IBAN`, `WALLET` etc). You can click on the dropdown next to the field in the schema below to view all supported payment types.
        * `destinationPaymentDetails` - Payment details (if any) used at the destination (ex: `CARD`, `IBAN`, `WALLET` etc). You can click on the dropdown next to the field in the schema below to view all supported payment types.

        Parameters
        ----------
        type : str
            Type of transaction (ex: DEPOSIT, WITHDRAWAL, TRANSFER, EXTERNAL_PAYMENT, REFUND, OTHER)

        transaction_id : str
            Unique transaction identifier

        timestamp : float
            Timestamp of when transaction took place

        validate_origin_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided originUserId exist. True by default

        validate_destination_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided destinationUserId exist. True by default

        origin_user_id : typing.Optional[str]
            UserId for where the transaction originates from

        destination_user_id : typing.Optional[str]
            UserId for transaction's destination. In other words, where the value is being transferred to.

        transaction_state : typing.Optional[TransactionState]

        origin_amount_details : typing.Optional[TransactionAmountDetails]

        destination_amount_details : typing.Optional[TransactionAmountDetails]

        origin_payment_details : typing.Optional[TransactionOriginPaymentDetails]
            Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.

        destination_payment_details : typing.Optional[TransactionDestinationPaymentDetails]

        origin_funds_info : typing.Optional[OriginFundsInfo]

        related_transaction_ids : typing.Optional[typing.Sequence[str]]
            IDs of transactions related to this transaction. Ex: refund, split bills

        product_type : typing.Optional[str]
            Type of produce being used by the consumer (ex wallets, payments etc)

        promotion_code_used : typing.Optional[bool]
            Whether a promotion code was used or not the transaction

        reference : typing.Optional[str]
            Reference field for the transaction indicating the purpose of the transaction etc.

        origin_device_data : typing.Optional[DeviceData]

        destination_device_data : typing.Optional[DeviceData]

        tags : typing.Optional[typing.Sequence[Tag]]
            Additional information that can be added via tags

        jurisdiction : typing.Optional[str]
            Legal authority or region governing the transaction

        update_count : typing.Optional[float]

        payment_approval_timestamp : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TransactionsVerifyResponse]
            Created
        """
        _response = self._client_wrapper.httpx_client.request(
            "transactions",
            method="POST",
            params={
                "validateOriginUserId": validate_origin_user_id,
                "validateDestinationUserId": validate_destination_user_id,
            },
            json={
                "type": type,
                "transactionId": transaction_id,
                "timestamp": timestamp,
                "originUserId": origin_user_id,
                "destinationUserId": destination_user_id,
                "transactionState": transaction_state,
                "originAmountDetails": convert_and_respect_annotation_metadata(
                    object_=origin_amount_details, annotation=TransactionAmountDetails, direction="write"
                ),
                "destinationAmountDetails": convert_and_respect_annotation_metadata(
                    object_=destination_amount_details, annotation=TransactionAmountDetails, direction="write"
                ),
                "originPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=origin_payment_details, annotation=TransactionOriginPaymentDetails, direction="write"
                ),
                "destinationPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=destination_payment_details,
                    annotation=TransactionDestinationPaymentDetails,
                    direction="write",
                ),
                "originFundsInfo": convert_and_respect_annotation_metadata(
                    object_=origin_funds_info, annotation=OriginFundsInfo, direction="write"
                ),
                "relatedTransactionIds": related_transaction_ids,
                "productType": product_type,
                "promotionCodeUsed": promotion_code_used,
                "reference": reference,
                "originDeviceData": convert_and_respect_annotation_metadata(
                    object_=origin_device_data, annotation=DeviceData, direction="write"
                ),
                "destinationDeviceData": convert_and_respect_annotation_metadata(
                    object_=destination_device_data, annotation=DeviceData, direction="write"
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags, annotation=typing.Sequence[Tag], direction="write"
                ),
                "jurisdiction": jurisdiction,
                "updateCount": update_count,
                "paymentApprovalTimestamp": payment_approval_timestamp,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransactionsVerifyResponse,
                    parse_obj_as(
                        type_=TransactionsVerifyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self, transaction_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[TransactionWithRulesResult]:
        """
        ### GET Transactions

        `/transactions` endpoint allows you to operate on the [Transaction entity](/guides/overview/entities#transaction).

        Calling `GET /transactions/{transactionId}` will return the entire transaction payload and rule execution results for the transaction with the corresponding `transactionId`

        Parameters
        ----------
        transaction_id : str
            Unique Transaction Identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TransactionWithRulesResult]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"transactions/{jsonable_encoder(transaction_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransactionWithRulesResult,
                    parse_obj_as(
                        type_=TransactionWithRulesResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawTransactionsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def verify(
        self,
        *,
        type: str,
        transaction_id: str,
        timestamp: float,
        validate_origin_user_id: typing.Optional[BooleanString] = None,
        validate_destination_user_id: typing.Optional[BooleanString] = None,
        origin_user_id: typing.Optional[str] = OMIT,
        destination_user_id: typing.Optional[str] = OMIT,
        transaction_state: typing.Optional[TransactionState] = OMIT,
        origin_amount_details: typing.Optional[TransactionAmountDetails] = OMIT,
        destination_amount_details: typing.Optional[TransactionAmountDetails] = OMIT,
        origin_payment_details: typing.Optional[TransactionOriginPaymentDetails] = OMIT,
        destination_payment_details: typing.Optional[TransactionDestinationPaymentDetails] = OMIT,
        origin_funds_info: typing.Optional[OriginFundsInfo] = OMIT,
        related_transaction_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        product_type: typing.Optional[str] = OMIT,
        promotion_code_used: typing.Optional[bool] = OMIT,
        reference: typing.Optional[str] = OMIT,
        origin_device_data: typing.Optional[DeviceData] = OMIT,
        destination_device_data: typing.Optional[DeviceData] = OMIT,
        tags: typing.Optional[typing.Sequence[Tag]] = OMIT,
        jurisdiction: typing.Optional[str] = OMIT,
        update_count: typing.Optional[float] = OMIT,
        payment_approval_timestamp: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TransactionsVerifyResponse]:
        """
        ## POST Transactions

        `/transactions` endpoint allows you to operate on the [Transaction entity.](/guides/overview/entities#transaction)

        In order to pass the payload of a transaction to Flagright and verify the transaction, you will need to call this endpoint with the transaction payload. Not all fields are mandatory, you will only need to pass in the fields that you have and are relevant for your compliance setup.


        ### Payload

        Here are some of the most used payload fields explained (you can find the full payload [schema below](/api-reference/api-reference/transactions/verify#request) with 1 line descriptions):

        * `type`: Type of transaction (Ex: `WITHDRAWAL`, `DEPOSIT`, `TRANSFER` etc).
        * `transactionId` - Unique Identifier for the transaction.
        * `timestamp` - UNIX timestamp in *milliseconds* of when the transaction took place
        * `transactionState` - The state of the transaction, set to `CREATED` by default. [More details here](/guides/overview/entities#transaction-lifecycle-through-transaction-events)
        * `originUserId` - Unique identifier (if any) of the user who is sending the money. This user must be created within the Flagright system before using the [create a consumer user](/api-reference/api-reference/consumer-users/create) or [create a business user](/api-reference/api-reference/business-users/create) endpoint
        * `destinationUserId` - Unique identifier (if any) of the user who is receiving the money. This user must be created within the Flagright system before using the [create a consumer user](/api-reference/api-reference/consumer-users/create) or [create a business user](/api-reference/api-reference/business-users/create) endpoint
        * `originAmountDetails` - Details of the amount being sent from the origin
        * `destinationAmountDetails` - Details of the amount being received at the destination
        * `originPaymentDetails` - Payment details (if any) used at the origin (ex: `CARD`, `IBAN`, `WALLET` etc). You can click on the dropdown next to the field in the schema below to view all supported payment types.
        * `destinationPaymentDetails` - Payment details (if any) used at the destination (ex: `CARD`, `IBAN`, `WALLET` etc). You can click on the dropdown next to the field in the schema below to view all supported payment types.

        Parameters
        ----------
        type : str
            Type of transaction (ex: DEPOSIT, WITHDRAWAL, TRANSFER, EXTERNAL_PAYMENT, REFUND, OTHER)

        transaction_id : str
            Unique transaction identifier

        timestamp : float
            Timestamp of when transaction took place

        validate_origin_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided originUserId exist. True by default

        validate_destination_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided destinationUserId exist. True by default

        origin_user_id : typing.Optional[str]
            UserId for where the transaction originates from

        destination_user_id : typing.Optional[str]
            UserId for transaction's destination. In other words, where the value is being transferred to.

        transaction_state : typing.Optional[TransactionState]

        origin_amount_details : typing.Optional[TransactionAmountDetails]

        destination_amount_details : typing.Optional[TransactionAmountDetails]

        origin_payment_details : typing.Optional[TransactionOriginPaymentDetails]
            Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.

        destination_payment_details : typing.Optional[TransactionDestinationPaymentDetails]

        origin_funds_info : typing.Optional[OriginFundsInfo]

        related_transaction_ids : typing.Optional[typing.Sequence[str]]
            IDs of transactions related to this transaction. Ex: refund, split bills

        product_type : typing.Optional[str]
            Type of produce being used by the consumer (ex wallets, payments etc)

        promotion_code_used : typing.Optional[bool]
            Whether a promotion code was used or not the transaction

        reference : typing.Optional[str]
            Reference field for the transaction indicating the purpose of the transaction etc.

        origin_device_data : typing.Optional[DeviceData]

        destination_device_data : typing.Optional[DeviceData]

        tags : typing.Optional[typing.Sequence[Tag]]
            Additional information that can be added via tags

        jurisdiction : typing.Optional[str]
            Legal authority or region governing the transaction

        update_count : typing.Optional[float]

        payment_approval_timestamp : typing.Optional[float]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TransactionsVerifyResponse]
            Created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "transactions",
            method="POST",
            params={
                "validateOriginUserId": validate_origin_user_id,
                "validateDestinationUserId": validate_destination_user_id,
            },
            json={
                "type": type,
                "transactionId": transaction_id,
                "timestamp": timestamp,
                "originUserId": origin_user_id,
                "destinationUserId": destination_user_id,
                "transactionState": transaction_state,
                "originAmountDetails": convert_and_respect_annotation_metadata(
                    object_=origin_amount_details, annotation=TransactionAmountDetails, direction="write"
                ),
                "destinationAmountDetails": convert_and_respect_annotation_metadata(
                    object_=destination_amount_details, annotation=TransactionAmountDetails, direction="write"
                ),
                "originPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=origin_payment_details, annotation=TransactionOriginPaymentDetails, direction="write"
                ),
                "destinationPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=destination_payment_details,
                    annotation=TransactionDestinationPaymentDetails,
                    direction="write",
                ),
                "originFundsInfo": convert_and_respect_annotation_metadata(
                    object_=origin_funds_info, annotation=OriginFundsInfo, direction="write"
                ),
                "relatedTransactionIds": related_transaction_ids,
                "productType": product_type,
                "promotionCodeUsed": promotion_code_used,
                "reference": reference,
                "originDeviceData": convert_and_respect_annotation_metadata(
                    object_=origin_device_data, annotation=DeviceData, direction="write"
                ),
                "destinationDeviceData": convert_and_respect_annotation_metadata(
                    object_=destination_device_data, annotation=DeviceData, direction="write"
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags, annotation=typing.Sequence[Tag], direction="write"
                ),
                "jurisdiction": jurisdiction,
                "updateCount": update_count,
                "paymentApprovalTimestamp": payment_approval_timestamp,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransactionsVerifyResponse,
                    parse_obj_as(
                        type_=TransactionsVerifyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, transaction_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[TransactionWithRulesResult]:
        """
        ### GET Transactions

        `/transactions` endpoint allows you to operate on the [Transaction entity](/guides/overview/entities#transaction).

        Calling `GET /transactions/{transactionId}` will return the entire transaction payload and rule execution results for the transaction with the corresponding `transactionId`

        Parameters
        ----------
        transaction_id : str
            Unique Transaction Identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TransactionWithRulesResult]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"transactions/{jsonable_encoder(transaction_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransactionWithRulesResult,
                    parse_obj_as(
                        type_=TransactionWithRulesResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

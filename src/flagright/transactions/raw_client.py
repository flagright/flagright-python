# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..types.transaction_type import TransactionType
from ..types.boolean_string import BooleanString
from ..types.transaction_state import TransactionState
from ..types.transaction_amount_details import TransactionAmountDetails
from ..types.transaction_origin_payment_details import TransactionOriginPaymentDetails
from ..types.transaction_destination_payment_details import TransactionDestinationPaymentDetails
from ..types.origin_funds_info import OriginFundsInfo
from ..types.device_data import DeviceData
from ..types.tag import Tag
from ..core.request_options import RequestOptions
from ..core.http_response import HttpResponse
from .types.transactions_verify_response import TransactionsVerifyResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..types.api_error_response import ApiErrorResponse
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.too_many_requests_error import TooManyRequestsError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.transaction_with_rules_result import TransactionWithRulesResult
from ..core.jsonable_encoder import jsonable_encoder
from ..core.client_wrapper import AsyncClientWrapper
from ..core.http_response import AsyncHttpResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawTransactionsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def verify(
        self,
        *,
        type: TransactionType,
        transaction_id: str,
        timestamp: float,
        validate_origin_user_id: typing.Optional[BooleanString] = None,
        validate_destination_user_id: typing.Optional[BooleanString] = None,
        validate_transaction_id: typing.Optional[BooleanString] = None,
        trs_only: typing.Optional[BooleanString] = None,
        origin_user_id: typing.Optional[str] = OMIT,
        destination_user_id: typing.Optional[str] = OMIT,
        transaction_state: typing.Optional[TransactionState] = OMIT,
        origin_amount_details: typing.Optional[TransactionAmountDetails] = OMIT,
        destination_amount_details: typing.Optional[TransactionAmountDetails] = OMIT,
        origin_payment_details: typing.Optional[TransactionOriginPaymentDetails] = OMIT,
        destination_payment_details: typing.Optional[TransactionDestinationPaymentDetails] = OMIT,
        origin_funds_info: typing.Optional[OriginFundsInfo] = OMIT,
        related_transaction_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        product_type: typing.Optional[str] = OMIT,
        promotion_code_used: typing.Optional[bool] = OMIT,
        reference: typing.Optional[str] = OMIT,
        origin_device_data: typing.Optional[DeviceData] = OMIT,
        destination_device_data: typing.Optional[DeviceData] = OMIT,
        tags: typing.Optional[typing.Sequence[Tag]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TransactionsVerifyResponse]:
        """
        ## POST Transactions

        `/transactions` endpoint allows you to operate on the [Transaction entity.](/guides/overview/entities#transaction)

        In order to pass the payload of a transaction to Flagright and verify the transaction, you will need to call this endpoint with the transaction payload. Not all fields are mandatory, you will only need to pass in the fields that you have and are relevant for your compliance setup.


        ### Payload

        Here are some of the most used payload fields explained (you can find the full payload [schema below](/api-reference/api-reference/transactions/verify#request) with 1 line descriptions):

        * `type`: Type of transaction (Ex: `WITHDRAWAL`, `DEPOSIT`, `TRANSFER` etc).
        * `transactionId` - Unique Identifier for the transaction.
        * `timestamp` - UNIX timestamp in *milliseconds* of when the transaction took place
        * `transactionState` - The state of the transaction, set to `CREATED` by default. [More details here](/guides/overview/entities#transaction-lifecycle-through-transaction-events)
        * `originUserId` - Unique identifier (if any) of the user who is sending the money. This user must be created within the Flagright system before using the [create a consumer user](/api-reference/api-reference/consumer-users/create) or [create a business user](/api-reference/api-reference/business-users/create) endpoint
        * `destinationUserId` - Unique identifier (if any) of the user who is receiving the money. This user must be created within the Flagright system before using the [create a consumer user](/api-reference/api-reference/consumer-users/create) or [create a business user](/api-reference/api-reference/business-users/create) endpoint
        * `originAmountDetails` - Details of the amount being sent from the origin
        * `destinationAmountDetails` - Details of the amount being received at the destination
        * `originPaymentDetails` - Payment details (if any) used at the origin (ex: `CARD`, `IBAN`, `WALLET` etc). You can click on the dropdown next to the field in the schema below to view all supported payment types.
        * `destinationPaymentDetails` - Payment details (if any) used at the destination (ex: `CARD`, `IBAN`, `WALLET` etc). You can click on the dropdown next to the field in the schema below to view all supported payment types.

        Parameters
        ----------
        type : TransactionType

        transaction_id : str
            Unique transaction identifier

        timestamp : float
            Timestamp of when transaction took place

        validate_origin_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided originUserId exist. True by default

        validate_destination_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided destinationUserId exist. True by default

        validate_transaction_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided transactionId exist. True by default

        trs_only : typing.Optional[BooleanString]

        origin_user_id : typing.Optional[str]
            UserId for where the transaction originates from

        destination_user_id : typing.Optional[str]
            UserId for transaction's destination. In other words, where the value is being transferred to.

        transaction_state : typing.Optional[TransactionState]

        origin_amount_details : typing.Optional[TransactionAmountDetails]

        destination_amount_details : typing.Optional[TransactionAmountDetails]

        origin_payment_details : typing.Optional[TransactionOriginPaymentDetails]
            Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.

        destination_payment_details : typing.Optional[TransactionDestinationPaymentDetails]

        origin_funds_info : typing.Optional[OriginFundsInfo]

        related_transaction_ids : typing.Optional[typing.Sequence[str]]
            IDs of transactions related to this transaction. Ex: refund, split bills

        product_type : typing.Optional[str]
            Type of produce being used by the consumer (ex wallets, payments etc)

        promotion_code_used : typing.Optional[bool]
            Whether a promotion code was used or not the transaction

        reference : typing.Optional[str]
            Reference field for the transaction indicating the purpose of the transaction etc.

        origin_device_data : typing.Optional[DeviceData]

        destination_device_data : typing.Optional[DeviceData]

        tags : typing.Optional[typing.Sequence[Tag]]
            Additional information that can be added via tags

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TransactionsVerifyResponse]
            Created
        """
        _response = self._client_wrapper.httpx_client.request(
            "transactions",
            method="POST",
            params={
                "validateOriginUserId": validate_origin_user_id,
                "validateDestinationUserId": validate_destination_user_id,
                "validateTransactionId": validate_transaction_id,
                "_trsOnly": trs_only,
            },
            json={
                "type": type,
                "transactionId": transaction_id,
                "timestamp": timestamp,
                "originUserId": origin_user_id,
                "destinationUserId": destination_user_id,
                "transactionState": transaction_state,
                "originAmountDetails": convert_and_respect_annotation_metadata(
                    object_=origin_amount_details, annotation=TransactionAmountDetails, direction="write"
                ),
                "destinationAmountDetails": convert_and_respect_annotation_metadata(
                    object_=destination_amount_details, annotation=TransactionAmountDetails, direction="write"
                ),
                "originPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=origin_payment_details, annotation=TransactionOriginPaymentDetails, direction="write"
                ),
                "destinationPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=destination_payment_details,
                    annotation=TransactionDestinationPaymentDetails,
                    direction="write",
                ),
                "originFundsInfo": convert_and_respect_annotation_metadata(
                    object_=origin_funds_info, annotation=OriginFundsInfo, direction="write"
                ),
                "relatedTransactionIds": related_transaction_ids,
                "productType": product_type,
                "promotionCodeUsed": promotion_code_used,
                "reference": reference,
                "originDeviceData": convert_and_respect_annotation_metadata(
                    object_=origin_device_data, annotation=DeviceData, direction="write"
                ),
                "destinationDeviceData": convert_and_respect_annotation_metadata(
                    object_=destination_device_data, annotation=DeviceData, direction="write"
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags, annotation=typing.Sequence[Tag], direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransactionsVerifyResponse,
                    parse_obj_as(
                        type_=TransactionsVerifyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, transaction_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[TransactionWithRulesResult]:
        """
        ### GET Transactions

        `/transactions` endpoint allows you to operate on the [Transaction entity](/guides/overview/entities#transaction).

        Calling `GET /transactions/{transactionId}` will return the entire transaction payload and rule execution results for the transaction with the corresponding `transactionId`

        Parameters
        ----------
        transaction_id : str
            Unique Transaction Identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TransactionWithRulesResult]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"transactions/{jsonable_encoder(transaction_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransactionWithRulesResult,
                    parse_obj_as(
                        type_=TransactionWithRulesResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRawTransactionsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def verify(
        self,
        *,
        type: TransactionType,
        transaction_id: str,
        timestamp: float,
        validate_origin_user_id: typing.Optional[BooleanString] = None,
        validate_destination_user_id: typing.Optional[BooleanString] = None,
        validate_transaction_id: typing.Optional[BooleanString] = None,
        trs_only: typing.Optional[BooleanString] = None,
        origin_user_id: typing.Optional[str] = OMIT,
        destination_user_id: typing.Optional[str] = OMIT,
        transaction_state: typing.Optional[TransactionState] = OMIT,
        origin_amount_details: typing.Optional[TransactionAmountDetails] = OMIT,
        destination_amount_details: typing.Optional[TransactionAmountDetails] = OMIT,
        origin_payment_details: typing.Optional[TransactionOriginPaymentDetails] = OMIT,
        destination_payment_details: typing.Optional[TransactionDestinationPaymentDetails] = OMIT,
        origin_funds_info: typing.Optional[OriginFundsInfo] = OMIT,
        related_transaction_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        product_type: typing.Optional[str] = OMIT,
        promotion_code_used: typing.Optional[bool] = OMIT,
        reference: typing.Optional[str] = OMIT,
        origin_device_data: typing.Optional[DeviceData] = OMIT,
        destination_device_data: typing.Optional[DeviceData] = OMIT,
        tags: typing.Optional[typing.Sequence[Tag]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TransactionsVerifyResponse]:
        """
        ## POST Transactions

        `/transactions` endpoint allows you to operate on the [Transaction entity.](/guides/overview/entities#transaction)

        In order to pass the payload of a transaction to Flagright and verify the transaction, you will need to call this endpoint with the transaction payload. Not all fields are mandatory, you will only need to pass in the fields that you have and are relevant for your compliance setup.


        ### Payload

        Here are some of the most used payload fields explained (you can find the full payload [schema below](/api-reference/api-reference/transactions/verify#request) with 1 line descriptions):

        * `type`: Type of transaction (Ex: `WITHDRAWAL`, `DEPOSIT`, `TRANSFER` etc).
        * `transactionId` - Unique Identifier for the transaction.
        * `timestamp` - UNIX timestamp in *milliseconds* of when the transaction took place
        * `transactionState` - The state of the transaction, set to `CREATED` by default. [More details here](/guides/overview/entities#transaction-lifecycle-through-transaction-events)
        * `originUserId` - Unique identifier (if any) of the user who is sending the money. This user must be created within the Flagright system before using the [create a consumer user](/api-reference/api-reference/consumer-users/create) or [create a business user](/api-reference/api-reference/business-users/create) endpoint
        * `destinationUserId` - Unique identifier (if any) of the user who is receiving the money. This user must be created within the Flagright system before using the [create a consumer user](/api-reference/api-reference/consumer-users/create) or [create a business user](/api-reference/api-reference/business-users/create) endpoint
        * `originAmountDetails` - Details of the amount being sent from the origin
        * `destinationAmountDetails` - Details of the amount being received at the destination
        * `originPaymentDetails` - Payment details (if any) used at the origin (ex: `CARD`, `IBAN`, `WALLET` etc). You can click on the dropdown next to the field in the schema below to view all supported payment types.
        * `destinationPaymentDetails` - Payment details (if any) used at the destination (ex: `CARD`, `IBAN`, `WALLET` etc). You can click on the dropdown next to the field in the schema below to view all supported payment types.

        Parameters
        ----------
        type : TransactionType

        transaction_id : str
            Unique transaction identifier

        timestamp : float
            Timestamp of when transaction took place

        validate_origin_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided originUserId exist. True by default

        validate_destination_user_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided destinationUserId exist. True by default

        validate_transaction_id : typing.Optional[BooleanString]
            Boolean string whether Flagright should validate if provided transactionId exist. True by default

        trs_only : typing.Optional[BooleanString]

        origin_user_id : typing.Optional[str]
            UserId for where the transaction originates from

        destination_user_id : typing.Optional[str]
            UserId for transaction's destination. In other words, where the value is being transferred to.

        transaction_state : typing.Optional[TransactionState]

        origin_amount_details : typing.Optional[TransactionAmountDetails]

        destination_amount_details : typing.Optional[TransactionAmountDetails]

        origin_payment_details : typing.Optional[TransactionOriginPaymentDetails]
            Payment details of the origin. It can be a bank account number, wallet ID, card fingerprint etc.

        destination_payment_details : typing.Optional[TransactionDestinationPaymentDetails]

        origin_funds_info : typing.Optional[OriginFundsInfo]

        related_transaction_ids : typing.Optional[typing.Sequence[str]]
            IDs of transactions related to this transaction. Ex: refund, split bills

        product_type : typing.Optional[str]
            Type of produce being used by the consumer (ex wallets, payments etc)

        promotion_code_used : typing.Optional[bool]
            Whether a promotion code was used or not the transaction

        reference : typing.Optional[str]
            Reference field for the transaction indicating the purpose of the transaction etc.

        origin_device_data : typing.Optional[DeviceData]

        destination_device_data : typing.Optional[DeviceData]

        tags : typing.Optional[typing.Sequence[Tag]]
            Additional information that can be added via tags

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TransactionsVerifyResponse]
            Created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "transactions",
            method="POST",
            params={
                "validateOriginUserId": validate_origin_user_id,
                "validateDestinationUserId": validate_destination_user_id,
                "validateTransactionId": validate_transaction_id,
                "_trsOnly": trs_only,
            },
            json={
                "type": type,
                "transactionId": transaction_id,
                "timestamp": timestamp,
                "originUserId": origin_user_id,
                "destinationUserId": destination_user_id,
                "transactionState": transaction_state,
                "originAmountDetails": convert_and_respect_annotation_metadata(
                    object_=origin_amount_details, annotation=TransactionAmountDetails, direction="write"
                ),
                "destinationAmountDetails": convert_and_respect_annotation_metadata(
                    object_=destination_amount_details, annotation=TransactionAmountDetails, direction="write"
                ),
                "originPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=origin_payment_details, annotation=TransactionOriginPaymentDetails, direction="write"
                ),
                "destinationPaymentDetails": convert_and_respect_annotation_metadata(
                    object_=destination_payment_details,
                    annotation=TransactionDestinationPaymentDetails,
                    direction="write",
                ),
                "originFundsInfo": convert_and_respect_annotation_metadata(
                    object_=origin_funds_info, annotation=OriginFundsInfo, direction="write"
                ),
                "relatedTransactionIds": related_transaction_ids,
                "productType": product_type,
                "promotionCodeUsed": promotion_code_used,
                "reference": reference,
                "originDeviceData": convert_and_respect_annotation_metadata(
                    object_=origin_device_data, annotation=DeviceData, direction="write"
                ),
                "destinationDeviceData": convert_and_respect_annotation_metadata(
                    object_=destination_device_data, annotation=DeviceData, direction="write"
                ),
                "tags": convert_and_respect_annotation_metadata(
                    object_=tags, annotation=typing.Sequence[Tag], direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransactionsVerifyResponse,
                    parse_obj_as(
                        type_=TransactionsVerifyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, transaction_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[TransactionWithRulesResult]:
        """
        ### GET Transactions

        `/transactions` endpoint allows you to operate on the [Transaction entity](/guides/overview/entities#transaction).

        Calling `GET /transactions/{transactionId}` will return the entire transaction payload and rule execution results for the transaction with the corresponding `transactionId`

        Parameters
        ----------
        transaction_id : str
            Unique Transaction Identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TransactionWithRulesResult]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"transactions/{jsonable_encoder(transaction_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransactionWithRulesResult,
                    parse_obj_as(
                        type_=TransactionWithRulesResult,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        ApiErrorResponse,
                        parse_obj_as(
                            type_=ApiErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

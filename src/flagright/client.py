# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from .core.api_error import ApiError
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_headers import remove_none_from_headers
from .environment import FlagrightEnvironment
from .errors.bad_request_error import BadRequestError
from .errors.too_many_requests_error import TooManyRequestsError
from .errors.unauthorized_error import UnauthorizedError
from .types.business import Business
from .types.business_optional import BusinessOptional
from .types.business_with_rules_result import BusinessWithRulesResult
from .types.device_data import DeviceData
from .types.post_business_user_response import PostBusinessUserResponse
from .types.post_consumer_transaction_response import PostConsumerTransactionResponse
from .types.post_consumer_user_response import PostConsumerUserResponse
from .types.transaction import Transaction
from .types.transaction_event_monitoring_result import TransactionEventMonitoringResult
from .types.transaction_state import TransactionState
from .types.transaction_updatable import TransactionUpdatable
from .types.transaction_with_rules_result import TransactionWithRulesResult
from .types.user import User
from .types.user_optional import UserOptional
from .types.user_with_rules_result import UserWithRulesResult

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class Flagright:
    def __init__(self, *, environment: FlagrightEnvironment = FlagrightEnvironment.DEFAULT, api_key: str):
        self._environment = environment
        self.api_key = api_key

    def post_consumer_transaction(
        self,
        *,
        validate_origin_user_id: typing.Optional[str] = None,
        validate_destination_user_id: typing.Optional[str] = None,
        request: Transaction,
    ) -> PostConsumerTransactionResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "transactions"),
            params={
                "validateOriginUserId": validate_origin_user_id,
                "validateDestinationUserId": validate_destination_user_id,
            },
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostConsumerTransactionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_consumer_transaction(self, transaction_id: str) -> TransactionWithRulesResult:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"transactions/{transaction_id}"),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TransactionWithRulesResult, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def post_transaction_event(
        self,
        *,
        transaction_state: TransactionState,
        timestamp: float,
        transaction_id: str,
        event_id: typing.Optional[str] = OMIT,
        reason: typing.Optional[str] = OMIT,
        event_description: typing.Optional[str] = OMIT,
        updated_transaction_attributes: typing.Optional[TransactionUpdatable] = OMIT,
        meta_data: typing.Optional[DeviceData] = OMIT,
    ) -> TransactionEventMonitoringResult:
        _request: typing.Dict[str, typing.Any] = {
            "transactionState": transaction_state,
            "timestamp": timestamp,
            "transactionId": transaction_id,
        }
        if event_id is not OMIT:
            _request["eventId"] = event_id
        if reason is not OMIT:
            _request["reason"] = reason
        if event_description is not OMIT:
            _request["eventDescription"] = event_description
        if updated_transaction_attributes is not OMIT:
            _request["updatedTransactionAttributes"] = updated_transaction_attributes
        if meta_data is not OMIT:
            _request["metaData"] = meta_data
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "events/transaction"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TransactionEventMonitoringResult, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def post_consumer_user(self, *, request: User) -> PostConsumerUserResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "consumer/users"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostConsumerUserResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_consumer_user(self, user_id: str) -> User:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"consumer/users/{user_id}"),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(User, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def post_business_user(self, *, request: Business) -> PostBusinessUserResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "business/users"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostBusinessUserResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_business_user_user_id(self, user_id: str) -> Business:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment.value}/", f"business/users/{user_id}"),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Business, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def post_user_event(
        self,
        *,
        timestamp: float,
        user_id: str,
        event_id: typing.Optional[str] = OMIT,
        reason: typing.Optional[str] = OMIT,
        event_description: typing.Optional[str] = OMIT,
        updated_consumer_user_attributes: typing.Optional[UserOptional] = OMIT,
    ) -> UserWithRulesResult:
        _request: typing.Dict[str, typing.Any] = {"timestamp": timestamp, "userId": user_id}
        if event_id is not OMIT:
            _request["eventId"] = event_id
        if reason is not OMIT:
            _request["reason"] = reason
        if event_description is not OMIT:
            _request["eventDescription"] = event_description
        if updated_consumer_user_attributes is not OMIT:
            _request["updatedConsumerUserAttributes"] = updated_consumer_user_attributes
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "events/consumer/user"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserWithRulesResult, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def post_business_user_event(
        self,
        *,
        timestamp: float,
        user_id: str,
        event_id: typing.Optional[str] = OMIT,
        reason: typing.Optional[str] = OMIT,
        event_description: typing.Optional[str] = OMIT,
        updated_business_user_attributes: typing.Optional[BusinessOptional] = OMIT,
    ) -> BusinessWithRulesResult:
        _request: typing.Dict[str, typing.Any] = {"timestamp": timestamp, "userId": user_id}
        if event_id is not OMIT:
            _request["eventId"] = event_id
        if reason is not OMIT:
            _request["reason"] = reason
        if event_description is not OMIT:
            _request["eventDescription"] = event_description
        if updated_business_user_attributes is not OMIT:
            _request["updatedBusinessUserAttributes"] = updated_business_user_attributes
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment.value}/", "events/business/user"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_headers({"x-api-key": self.api_key}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(BusinessWithRulesResult, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncFlagright:
    def __init__(self, *, environment: FlagrightEnvironment = FlagrightEnvironment.DEFAULT, api_key: str):
        self._environment = environment
        self.api_key = api_key

    async def post_consumer_transaction(
        self,
        *,
        validate_origin_user_id: typing.Optional[str] = None,
        validate_destination_user_id: typing.Optional[str] = None,
        request: Transaction,
    ) -> PostConsumerTransactionResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "transactions"),
                params={
                    "validateOriginUserId": validate_origin_user_id,
                    "validateDestinationUserId": validate_destination_user_id,
                },
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostConsumerTransactionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_consumer_transaction(self, transaction_id: str) -> TransactionWithRulesResult:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"transactions/{transaction_id}"),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TransactionWithRulesResult, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def post_transaction_event(
        self,
        *,
        transaction_state: TransactionState,
        timestamp: float,
        transaction_id: str,
        event_id: typing.Optional[str] = OMIT,
        reason: typing.Optional[str] = OMIT,
        event_description: typing.Optional[str] = OMIT,
        updated_transaction_attributes: typing.Optional[TransactionUpdatable] = OMIT,
        meta_data: typing.Optional[DeviceData] = OMIT,
    ) -> TransactionEventMonitoringResult:
        _request: typing.Dict[str, typing.Any] = {
            "transactionState": transaction_state,
            "timestamp": timestamp,
            "transactionId": transaction_id,
        }
        if event_id is not OMIT:
            _request["eventId"] = event_id
        if reason is not OMIT:
            _request["reason"] = reason
        if event_description is not OMIT:
            _request["eventDescription"] = event_description
        if updated_transaction_attributes is not OMIT:
            _request["updatedTransactionAttributes"] = updated_transaction_attributes
        if meta_data is not OMIT:
            _request["metaData"] = meta_data
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "events/transaction"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TransactionEventMonitoringResult, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def post_consumer_user(self, *, request: User) -> PostConsumerUserResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "consumer/users"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostConsumerUserResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_consumer_user(self, user_id: str) -> User:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"consumer/users/{user_id}"),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(User, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def post_business_user(self, *, request: Business) -> PostBusinessUserResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "business/users"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostBusinessUserResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_business_user_user_id(self, user_id: str) -> Business:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment.value}/", f"business/users/{user_id}"),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Business, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def post_user_event(
        self,
        *,
        timestamp: float,
        user_id: str,
        event_id: typing.Optional[str] = OMIT,
        reason: typing.Optional[str] = OMIT,
        event_description: typing.Optional[str] = OMIT,
        updated_consumer_user_attributes: typing.Optional[UserOptional] = OMIT,
    ) -> UserWithRulesResult:
        _request: typing.Dict[str, typing.Any] = {"timestamp": timestamp, "userId": user_id}
        if event_id is not OMIT:
            _request["eventId"] = event_id
        if reason is not OMIT:
            _request["reason"] = reason
        if event_description is not OMIT:
            _request["eventDescription"] = event_description
        if updated_consumer_user_attributes is not OMIT:
            _request["updatedConsumerUserAttributes"] = updated_consumer_user_attributes
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "events/consumer/user"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserWithRulesResult, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def post_business_user_event(
        self,
        *,
        timestamp: float,
        user_id: str,
        event_id: typing.Optional[str] = OMIT,
        reason: typing.Optional[str] = OMIT,
        event_description: typing.Optional[str] = OMIT,
        updated_business_user_attributes: typing.Optional[BusinessOptional] = OMIT,
    ) -> BusinessWithRulesResult:
        _request: typing.Dict[str, typing.Any] = {"timestamp": timestamp, "userId": user_id}
        if event_id is not OMIT:
            _request["eventId"] = event_id
        if reason is not OMIT:
            _request["reason"] = reason
        if event_description is not OMIT:
            _request["eventDescription"] = event_description
        if updated_business_user_attributes is not OMIT:
            _request["updatedBusinessUserAttributes"] = updated_business_user_attributes
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment.value}/", "events/business/user"),
                json=jsonable_encoder(_request),
                headers=remove_none_from_headers({"x-api-key": self.api_key}),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(BusinessWithRulesResult, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
